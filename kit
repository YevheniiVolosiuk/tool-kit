#!/usr/bin/env bash

export ROOT_DIRECTORY="$PWD"
export BIN_DIRECTORY="$PWD/bin"
export APPS_DIRECTORY="$PWD/apps"
export TEMPLATES_DIRECTORY="$PWD/templates"

source "$BIN_DIRECTORY/helpers/color_helpers.sh"
source "$BIN_DIRECTORY/helpers/functions.sh"

# GENERAL COMMAND FORMAT
# kit [app] [env] [command] [args]
#   [app] in subdirectory of ./apps directory
#   [env] in (dev, prod)
# SHORTENED VERSIONS
# kit [env] [command] [args]  same as kit first_app [env] [command] [args]
# kit [command] [args]        same as kt first_app dev [command] [args]

export APP="$1"
export ENV="$2"
export COMMAND="$3"

if [ -d "${APPS_DIRECTORY}/${APP}" ]; then
  # Found a valid app. Shift arguments to prepare for ARGS="$@" line below
  shift 1
else
  # If first argument is not a directory in /apps, default to first app in /apps directory and shift variables
  APP_DIR=$(ls -d "$APPS_DIRECTORY"/* | head -1)
  echo "APP_DIR: $APP_DIR"
  APP=$(basename "$APP_DIR")
  ENV="$1"
  COMMAND="$2"
fi

if [ "$ENV" == "dev" ] || [ "$ENV" == "prod" ] || [ "$ENV" == "stage" ]; then
  # Found a valid env. Shift arguments to prepare for ARGS="$@" line below
  shift 1
else
  # Did not find a valid env. Default to 'dev' and shift the command
  ENV="dev"
  COMMAND="$1"
fi

# Shift off the command to leave just the args variable
shift 1
ARGS=$@

export APP_DIRECTORY="${APPS_DIRECTORY}/${APP}"
export ENV_FILE="$APP_DIRECTORY/.env.${ENV}"
export PATH_TO_CODE="$ROOT_DIRECTORY/../code/${APP}"

# TEMPLATE - allow the application template to set environment variables
if [ -f "$APP_DIRECTORY/bin/set_env.sh" ]; then
  source "$APP_DIRECTORY/bin/set_env.sh"
fi

# Debugging lines (normally keep this commented out)
echo_divider
echo -e "${RED}NEW COMMAND:${RESET} APP: ${BLUE}$APP${RESET}, ENV: ${BLUE}$ENV${RESET}, COMMAND: ${BLUE}$COMMAND${RESET}, ARGS: ${BLUE}$ARGS${RESET}, SERVICE: ${BLUE}$ENTRY_SERVICE${RESET}"
#echo_blue "APP_DIRECTORY: $APP_DIRECTORY"
#echo_blue "ENTRY_SERVICE: $ENTRY_SERVICE"
#echo_blue "PATH_TO_CODE: $PATH_TO_CODE"
echo_divider

# Exit early if the ENV_FILE does not exist
if [ -n "$APP" ] && [ ! -f "$ENV_FILE" ]; then
  echo_red "The env file for the application does not exist!!"
  echo_red "Expected file here: $ENV_FILE"
  exit 1
fi

# Warn if code directory does not exist
if [ "$COMMAND" != 'create' ] && [ ! -d "$PATH_TO_CODE" ]; then
  echo_yellow "No code for the application found!!"
  echo_yellow "Expected code here: $PATH_TO_CODE"
  echo_yellow "Try running the 'kit $APP create' command."
fi

# Make variables in the ENV_FILE accessible to the script
if [ -f "$ENV_FILE" ]; then
  set -a # automatically export all variables
  source "$ENV_FILE"
  set +a
fi

# Helper function to run docker compose commands
function run_docker_compose()
{
  set -o xtrace
  docker compose -f "${APP_DIRECTORY}/docker-compose.yml" -f "${APP_DIRECTORY}/docker-compose.${ENV}.yml" --env-file "$ENV_FILE" "$@"
  set +o xtrace
}

# Handle the command
# TEMPLATE - First look into the template bin/commands directory
COMMAND_FILE="${APP_DIRECTORY}/bin/commands/${COMMAND}.sh"
if [ -f "$COMMAND_FILE" ]; then
  source "$COMMAND_FILE"
  # shellcheck disable=SC2086
  command_run $ARGS
else
  # Next look into the main directory for kit commands
  COMMAND_FILE="$BIN_DIRECTORY/commands/$COMMAND.sh"
  if [ -f "$COMMAND_FILE" ]; then
      source "$COMMAND_FILE"
      # shellcheck disable=SC2086
      command_run $ARGS
  else
      source "$BIN_DIRECTORY/commands/help.sh"
      # shellcheck disable=SC2086
      command_run $ARGS
  fi
fi